<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C/DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
  <head>
    <meta http-equiv = "Content-Type" content = "text/html; charset=utf-8" />
    <meta http-equiv = "Content-Style-Type" content = "text/css" />
    <meta http-equiv = "Content-Script-Type" content = "text/javascript" />
  </head>
  <body>
    <h1>sworks.mqo.parser</h1>
    <!-- Generated by Ddoc from src\sworks\mqo\parser.d -->
<p class='summary-sec'>Metasequoia ファイルのパースに。
</p>
<span class='summary-header-sec version-sec'>0.0001(dmd2.062)
</span><br />

<span class='summary-header-sec date-sec'>2013-Mar-27 03:45:29
</span><br />

<span class='summary-header-sec authors-sec'>KUMA
</span><br />

<span class='summary-header-sec license-sec'>CC0</span><br />


<dl class='module-members-sec'><dt><span class='decl'><a name="MQ_NEWLINE"></a>string <span class='psymbol'>MQ_NEWLINE</span>;
</span></dt>
<dd><p class='summary-sec'>Metasequoia では改行コードは MS式で固定(?)</p>

</dd>
<dt><span class='decl'><a name="SyntaxException"></a>class <span class='psymbol'>SyntaxException</span>: object.Exception;
</span></dt>
<dd><p class='summary-sec'>version(STRICT) では、よりたくさん例外を投げる。
 debug コンパイルでは STRICT がデフォルト。</p>

</dd>
<dt><span class='decl'><a name="enforceSyntax"></a>T <span class='psymbol'>enforceSyntax</span>(T)(T <span class='param'>cond</span>, in MqoFile <span class='param'>file</span>, lazy string <span class='param'>msg</span>, string <span class='param'>filename</span> = __FILE__, int <span class='param'>line</span> = __LINE__);
</span></dt>
<dd><p class='summary-sec'><span class='param'>cond</span> が偽の時、SyntaxExceptionを投げる。</p>

</dd>
<dt><span class='decl'><a name="MqoFile"></a>class <span class='psymbol'>MqoFile</span>: sworks.compo.util.cached_buffer.TICache!(byte).TICache;
</span></dt>
<dd><p class='summary-sec'>Metasequoia ファイルを格納する。</p>

<dl class='members-sec'><dt><span class='decl'><a name="MqoFile.this"></a> this(string <span class='param'>filename</span>);
</span></dt>
<dd><p class='summary-sec'><span class='param'><span class='param'>filename</span></span> は Metasequoia ファイル名</p>

</dd>
<dt><span class='decl'><a name="MqoFile.this"></a> this(jstring <span class='param'>filecont</span>);
</span></dt>
<dd><p class='summary-sec'> は Metasequoia ファイルの中身。文字コードは SHIFT-JIS</p>

</dd>
<dt><span class='decl'><a name="MqoFile.filename"></a>const @property string <span class='psymbol'>filename</span>();
</span></dt>
<dd><p class='summary-sec'>.mqo ファイル名。<br />

 this( jstring <span class='param'>filecont</span> ) でインスタンス化された場合、値は <q>JSTRING</q></p>

</dd>
<dt><span class='decl'><a name="MqoFile.size"></a>const @property size_t <span class='psymbol'>size</span>();
</span></dt>
<dd><p class='summary-sec'>キャッシュサイズ。</p>

</dd>
<dt><span class='decl'><a name="MqoFile.rest"></a>const @property const(byte)[] <span class='psymbol'>rest</span>();
</span></dt>
<dd><p class='summary-sec'>キャッシュの残り。</p>

</dd>
<dt><span class='decl'><a name="MqoFile.eof"></a>const @property bool <span class='psymbol'>eof</span>();
</span></dt>
<dd><p class='summary-sec'>ファイル終端に達しているかどうか</p>

</dd>
<dt><span class='decl'><a name="MqoFile.position"></a>const @property size_t <span class='psymbol'>position</span>();
</span></dt>
<dd><p class='summary-sec'>ファイル内でのオフセット</p>

</dd>
<dt><span class='decl'><a name="MqoFile.front"></a>const @property jchar <span class='psymbol'>front</span>();
</span></dt>
<dd><p class='summary-sec'>キャッシュの先頭一文字</p>

</dd>
<dt><span class='decl'><a name="MqoFile.popFront"></a>jchar <span class='psymbol'>popFront</span>(size_t <span class='param'>s</span> = 1);
</span></dt>
<dd><p class='summary-sec'>カーソルを <span class='param'><span class='param'>s</span></span> 字進める。</p>

</dd>
<dt><span class='decl'><a name="MqoFile.peek"></a>const(byte)[] <span class='psymbol'>peek</span>(size_t <span class='param'>size</span>);
</span></dt>
<dd><p class='summary-sec'><span class='param'><span class='param'>size</span></span> byteチラ見する。カーソルは進めない。キャッシュサイズより沢山 <span class='psymbol'>peek</span> できない。</p>

</dd>
<dt><span class='decl'><a name="MqoFile.peekBetter"></a>const(byte)[] <span class='psymbol'>peekBetter</span>();
</span></dt>
<dd><p class='summary-sec'>メモリコピーをなるべく減らすヴァージョン</p>

</dd>
<dt><span class='decl'><a name="MqoFile.close"></a>void <span class='psymbol'>close</span>();
</span></dt>
<dd><p class='summary-sec'>ファイルを閉じられる場合は閉じる。</p>

</dd>
<dt><span class='decl'><a name="MqoFile.getBinary"></a>jstring <span class='psymbol'>getBinary</span>(size_t <span class='param'>size</span>);
<br />
<a name="MqoFile.getBinary"></a>byte[] <span class='psymbol'>getBinary</span>(byte[] <span class='param'>buf</span>);
</span></dt>
<dd><p class='summary-sec'>キャッシュ先頭から <span class='param'><span class='param'>size</span></span> byte 読み込み、その分のカーソルを進める。</p>

</dd>
<dt><span class='decl'><a name="MqoFile.push"></a>jchar <span class='psymbol'>push</span>(size_t <span class='param'>s</span> = 1);
</span></dt>
<dd><p class='summary-sec'>一時記憶領域にキャッシュ先頭の <span class='param'><span class='param'>s</span></span> 字を記憶し、その分のカーソルを進める。</p>

</dd>
<dt><span class='decl'><a name="MqoFile.push"></a>jchar <span class='psymbol'>push</span>(jchar <span class='param'>jc</span>);
</span></dt>
<dd><p class='summary-sec'>一時記憶領域に <span class='param'><span class='param'>jc</span></span> を記憶し、カーソルを1進める。</p>

</dd>
<dt><span class='decl'><a name="MqoFile.stack"></a>const @property const(byte)[] <span class='psymbol'>stack</span>();
</span></dt>
<dd><p class='summary-sec'>一時記憶領域を内容を返す。</p>

</dd>
<dt><span class='decl'><a name="MqoFile.flush"></a>void <span class='psymbol'>flush</span>();
</span></dt>
<dd><p class='summary-sec'>一時記憶領域の内容をクリアする。</p>

</dd>
<dt><span class='decl'><a name="MqoFile.msg"></a>string <span class='psymbol'>msg</span>(string <span class='psymbol'>msg</span>);
</span></dt>
<dd><p class='summary-sec'>現在のキャッシュの内容で例外用のメッセージを作る。</p>

</dd>
</dl>
</dd>
<dt><span class='decl'><a name="INamed"></a>abstract interface <span class='psymbol'>INamed</span>;
<br />
<a name="INamable"></a><a name="<span class='psymbol'>INamable</span>"></a>abstract interface <span class='psymbol'><span class='psymbol'>INamable</span></span>: sworks.mqo.parser.INamed;
<br />
<a name="ILength"></a><a name="<span class='psymbol'>ILength</span>"></a>abstract interface <span class='psymbol'><span class='psymbol'>ILength</span></span>;
<br />
<a name="IOwnParser"></a><a name="<span class='psymbol'>IOwnParser</span>"></a>abstract interface <span class='psymbol'><span class='psymbol'>IOwnParser</span></span>;
</span></dt>
<dd><p class='summary-sec'>クラスで実装し、パーサ生成に利用する。</p>

</dd>
<dt><span class='decl'><a name="Token"></a>struct <span class='psymbol'>Token</span>;
</span></dt>
<dd><p class='summary-sec'>ファイルの先頭1トークンの情報を格納している。<br />

 popFront を呼び出してファイル内を巡回する。
</p>
<p class='bug-sec'>issue 8484(<a href="http://d.puremagic.com/issues/show_bug.cgi?id=8484">http://d.puremagic.com/issues/show_bug.cgi?id=8484</a>) 回避の為(@2059) 構造体である必要がある。</p>

<dl class='members-sec'><dt><span class='decl'><a name="Token.TYPE"></a>enum <span class='psymbol'>TYPE</span>;
</span></dt>
<dd><p class='summary-sec'>トークンのタイプ</p>

</dd>
<dt><span class='decl'><a name="Token.this"></a> this(MqoFile <span class='param'>file</span>);
</span></dt>
<dd><br />
<br />

</dd>
<dt><span class='decl'><a name="Token.toString"></a>const @property string <span class='psymbol'>toString</span>();
<br />
<a name="Token.toJString"></a>const @property jstring <span class='psymbol'>toJString</span>();
<br />
<a name="Token.toKeyword"></a>const @property string <span class='psymbol'>toKeyword</span>();
<br />
<a name="Token.toInt"></a>const @property int <span class='psymbol'>toInt</span>();
<br />
<a name="Token.toFloat"></a>const @property float <span class='psymbol'>toFloat</span>();
</span></dt>
<dd><p class='summary-sec'>トークン → D言語の基本型</p>

</dd>
<dt><span class='decl'><a name="Token.toBinary"></a>const @property immutable(ubyte)[] <span class='psymbol'>toBinary</span>();
</span></dt>
<dd><p class='summary-sec'>BVertex チャンク読み込み時に利用される。戻り値は ubyte[] なので、cast して使って下さい。</p>

</dd>
<dt><span class='decl'><a name="Token.popFront"></a>void <span class='psymbol'>popFront</span>();
</span></dt>
<dd><p class='summary-sec'>次のトークンに処理を移す。</p>

</dd>
<dt><span class='decl'><a name="Token.chomp"></a>void <span class='psymbol'>chomp</span>(OBJECT)(ref OBJECT <span class='param'>t</span>);
</span></dt>
<dd><p class='summary-sec'>現在のトークンから OBJECT を切り出す。
</p>
<b>Params:</b><br />
<table border='1' cellpadding='8' cellspacing='0' frame='void' rules='rows' class='params'><tr><td class='params_id'>t</td>
<td>ここに切り出された値が格納される。</td></tr>
</table><br />

<b>Throws:</b><br />

SyntaxException が予期せぬ事態に投げられる。
<br />
<br />

<p class='bug-sec'>OBJECT は引数無しのコンストラクタを持っている必要がある。
<br />
<br />


 処理は再帰的に行なわれる。
 <ol>
   <li> OBJECT が D言語の基本型の場合はそのまま std.conv に渡す。</li>
   <li> OBJECT が静的配列の場合は、丁度配列長分だけ、<span class='psymbol'>chomp</span> を再帰呼び出しする。</li>
   <li> OBJECT が動的配列の場合は、次のトークンが配列長を示し、その後に配列の内容が続いているとする。</li>
   <li> OBJECT が構造体の場合は、ソースコード上でメンバの定義順に <span class='psymbol'>chomp</span> を再帰呼び出しする。</li>
   <li> OBJECT がクラスの場合は、キーワードにマッチするメンバで <span class='psymbol'>chomp</span> を再帰呼び出しする。</li>
 </ol>
<br />
<br />


 メンバに特殊な書式をパースする必要がある場合、<br />

 IOwnParser インターフェイスを実装して下さい。<br />

 クラスの他のメンバ名と、token.toKeyword がヒットしなかった場合、parser が呼ばれる。<br />

 parser で処理した場合は内部でその分 token を進めて下さい。<br />

 続けて同じインスタンスに対して <span class='psymbol'>chomp</span> を呼び出す場合は parser から <span class='dkeyword'>true</span> を返し、<br />

 そのインスタンスに対する処理を終える場合は <span class='dkeyword'>false</span> を返して下さい。<br />
</p>

</dd>
</dl>
</dd>
<dt><span class='decl'><a name="checkHeader"></a>string <span class='psymbol'>checkHeader</span>(MqoFile <span class='param'>file</span>, string <span class='param'>reg</span>);
</span></dt>
<dd><p class='summary-sec'>ヘッダの読み込み。
</p>
<b>Params:</b><br />
<table border='1' cellpadding='8' cellspacing='0' frame='void' rules='rows' class='params'><tr><td class='params_id'>string <span class='param'>reg</span></td>
<td>ヘッダ文字列。ヴァージョン文字列が始まる直前まで。
   <del><span class='param'>reg</span> = ヘッダにヒットする正規表現。captures[1] にヴァージョン文字列が入るようにする。</del>( after ver0.0011 )<br />
</td></tr>
</table><br />


</dd>
<dt><span class='decl'><a name="load"></a>OBJECT <span class='psymbol'>load</span>(OBJECT)(string <span class='param'>filename</span>);
</span></dt>
<dd><p class='summary-sec'>ファイル -&gt; D言語のオブジェクト
</p>
<b>Params:</b><br />
<table border='1' cellpadding='8' cellspacing='0' frame='void' rules='rows' class='params'><tr><td class='params_id'>filename</td>
<td>ファイル名。</td></tr>
<tr><td class='params_id'>OBJECT</td>
<td>OBJECT.HEADER に、ヘッダ文字列をしこんでおく。</td></tr>
</table><br />

<b>Returns:</b><br />

中身のばっちりつまった OBJECT型のインスタンス。
<br />
<br />

<b>Throws:</b><br />

Exception パースに失敗した場合投げられる。<br />
<br />


</dd>
</dl>

  </body>
</html>

