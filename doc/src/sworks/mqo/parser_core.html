<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C/DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
  <head>
    <meta http-equiv = "Content-Type" content = "text/html; charset=utf-8" />
    <meta http-equiv = "Content-Style-Type" content = "text/css" />
    <meta http-equiv = "Content-Script-Type" content = "text/javascript" />
  </head>
  <body>
    <h1>sworks.mqo.parser_core</h1>
    <!-- Generated by Ddoc from src\sworks\mqo\parser_core.d -->
<p class="summary-sec">Metasequoia ファイルのパースに。ランタイム、コンパイルタイム、で共用できる部分
</p>

<span class="summary-header-sec version-sec">0.0011(dmd2.060)
</span><br />


<span class="summary-header-sec date-sec">2012-Aug-16 02:48:01
</span><br />


<span class="summary-header-sec authors-sec">KUMA
</span><br />


<span class="summary-header-sec license-sec">CC0</span><br />



<dl class="module-members-sec"><dt><span class="decl">string <span class="psymbol">MQ_NEWLINE</span>
;
</span></dt>

<dd><p class="summary-sec">Metasequoia では改行コードは MS式で固定(?)</p>


</dd>
<dt><span class="decl">class <span class="psymbol">SyntaxException</span>
: object.Exception;
</span></dt>

<dd><p class="summary-sec">parse 時に投げられる。
 version(STRICT) では、よりたくさん例外を投げる。
 debug コンパイルでは STRICT がデフォルト。</p>


<dl class="members-sec"><dt><span class="decl">this(uint <span class="param">line_num</span>
, string <span class="param">cell_cont</span>
, string <span class="param">msg</span>
, string <span class="param">filename</span>
 = __FILE__, int <span class="param">line</span>
 = __LINE__);
</span></dt>

<dd><b>Params:</b><br />
<table border="1" frame="void" rules="rows" class="params"><tr><td class="params_id">uint <span class="param">line_num</span>
</td>

<td>問題が起きた対象ファイル内での行数。CachedFile が保持している。</td></tr>
<tr><td class="params_id">string <span class="param">cell_cont</span>
</td>

<td>問題の箇所</td></tr>
<tr><td class="params_id">string <span class="param">msg</span>
</td>

<td>ここにスタックトレース情報が入っていることを期待している。</td></tr>
</table><br />



</dd>
</dl>

</dd>
<dt><span class="decl">abstract interface <span class="psymbol">ICachedBuffer</span>
;
</span></dt>

<dd><p class="summary-sec">バッファの先頭一文字を読み取るけど、カーソルは進めない、peep 関数を実装する。</p>


</dd>
<dt><span class="decl">struct <span class="psymbol">Token</span>
;
</span></dt>

<dd><p class="summary-sec">ファイルの先頭1トークンの情報を格納している。<br />

 popFront を呼び出してファイル内を巡回する。
</p>

<p class="bug-sec">issue 8484 ( http://d.puremagic.com/issues/show_bug.cgi?id=8484 ) 回避の為(@2059) 構造体である必要がある。</p>

<dl class="members-sec"><dt><span class="decl">enum <span class="psymbol">TYPE</span>
;
</span></dt>

<dd><p class="summary-sec">トークンのタイプ</p>


</dd>
<dt><span class="decl">const @property string <span class="psymbol">toString</span>
();
<br />
const @property jstring <span class="psymbol">toJString</span>
();
<br />
const @property string <span class="psymbol">toKeyword</span>
();
<br />
const @property int <span class="psymbol">toInt</span>
();
<br />
const @property float <span class="psymbol">toFloat</span>
();
</span></dt>

<dd><p class="summary-sec">トークン → D言語の基本型</p>


</dd>
<dt><span class="decl">const @property immutable(ubyte)[] <span class="psymbol">toBinary</span>
();
</span></dt>

<dd><p class="summary-sec">BVertex チャンク読み込み時に利用される。戻り値は ubyte[] なので、cast して使って下さい。</p>


</dd>
<dt><span class="decl">void <span class="psymbol">popFront</span>
();
</span></dt>

<dd><p class="summary-sec">次のトークンに処理を移す。</p>


</dd>
<dt><span class="decl">void <span class="psymbol">chomp</span>
(OBJECT)(ref OBJECT <span class="param">t</span>
);
</span></dt>

<dd><p class="summary-sec">現在のトークンから OBJECT を切り出す。
</p>

<b>Params:</b><br />
<table border="1" frame="void" rules="rows" class="params"><tr><td class="params_id">t</td>

<td>ここに切り出された値が格納される。</td></tr>
</table><br />


<b>Throws:</b><br />

SyntaxException 予期せぬ事態の場合に投げられる。
<br />
<br />

<p class="bug-sec">OBJECT は引数無しのコンストラクタを持っている必要がある。
<br />
<br />


 処理は再帰的に行なわれる。
 <ol>
   <li> OBJECT が D言語の基本型の場合はそのまま std.conv に渡す。</li>
   <li> OBJECT が静的配列の場合は、丁度配列長分だけ、<span class="psymbol">chomp</span>
 を再帰呼び出しする。</li>
   <li> OBJECT が動的配列の場合は、次のトークンが配列長を示し、その後に配列の内容が続いているとする。</li>
   <li> OBJECT が構造体の場合は、ソースコード上でメンバの定義順に <span class="psymbol">chomp</span>
 を再帰呼び出しする。</li>
   <li> OBJECT がクラスの場合は、キーワードにマッチするメンバで <span class="psymbol">chomp</span>
 を再帰呼び出しする。</li>
 </ol>
<br />
<br />


 メンバに特殊な書式をパースする必要がある場合、<br />

 IOwnParser インターフェイスを実装して下さい。<br />

 というメンバを定義する。<br />

 クラスの他のメンバ名と、token.toKeyword がヒットしなかった場合、parser が呼ばれる。<br />

 parser で処理した場合は内部でその分 token を進めて下さい。<br />

 続けて同じインスタンスに対して <span class="psymbol">chomp</span>
 を呼び出す場合は parser から <span class="dkeyword">true</span>
 を返し、<br />

 そのインスタンスに対する処理を終える場合は <span class="dkeyword">false</span>
 を返して下さい。<br />
</p>

</dd>
</dl>

</dd>
<dt><span class="decl">void <span class="psymbol">check_header</span>
(ICachedBuffer <span class="param">cf</span>
, string <span class="param">reg</span>
);
</span></dt>

<dd><p class="summary-sec">ヘッダの読み込み。
</p>

<b>Params:</b><br />
<table border="1" frame="void" rules="rows" class="params"><tr><td class="params_id">string <span class="param">reg</span>
</td>

<td><del>ヘッダにヒットする正規表現。captures[1] にヴァージョン文字列が入るようにする。</del>( after ver0.0011 )<br />
</td></tr>
</table><br />


<b>Return:</b><br />

<del>ヴァージョン文字列</del><br />
<br />


</dd>
</dl>


  </body>
</html>

