<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C/DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
  <head>
    <meta http-equiv = "Content-Type" content = "text/html; charset=utf-8" />
    <meta http-equiv = "Content-Style-Type" content = "text/css" />
    <meta http-equiv = "Content-Script-Type" content = "text/javascript" />
  </head>
  <body>
    <h1>sworks.mqo.misc</h1>
    <!-- Generated by Ddoc from src\sworks\mqo\misc.d -->
<p class="summary-sec">こまごましたのん。
</p>

<span class="summary-header-sec version-sec">0.0011(dmd2.060)
</span><br />


<span class="summary-header-sec date-sec">2012-Aug-16 02:48:01
</span><br />


<span class="summary-header-sec authors-sec">KUMA
</span><br />


<span class="summary-header-sec license-sec">CC0</span><br />



<dl class="module-members-sec"><dt><span class="decl">alias <span class="psymbol">jstring</span>
;
</span></dt>

<dd><p class="summary-sec">SHIFT-JIS の格納に<br />

 コンパイル時評価に向けて、文字コードの変換は遅延させる。</p>


</dd>
<dt><span class="decl">jstring <span class="psymbol">j</span>
(T)(T[] <span class="param">str</span>
);
<br />
string <span class="psymbol">c</span>
(T)(T[] <span class="param">jstr</span>
);
</span></dt>

<dd><p class="summary-sec">suger</p>


</dd>
<dt><span class="decl">struct <span class="psymbol">Color3</span>
(PRECISION);
</span></dt>

<dd><p class="summary-sec">アルファ値なし色情報</p>


</dd>
<dt><span class="decl">struct <span class="psymbol">Color4</span>
(PRECISION);
</span></dt>

<dd><p class="summary-sec">アルファ値あり色情報</p>


</dd>
<dt><span class="decl">struct <span class="psymbol">UVCoordination</span>
(PRECISION);
</span></dt>

<dd><p class="summary-sec">テクスチャ座標</p>


</dd>
<dt><span class="decl">struct <span class="psymbol">FramedTranslation</span>
(PRECISION);
</span></dt>

<dd><p class="summary-sec">モーションの各キーフレームでの平行移動の状態を示す。<br />

 ボーンの原点の初期位置からの移動量で表わされているようだ。<br />
</p>


</dd>
<dt><span class="decl">struct <span class="psymbol">FramedRotation</span>
(PRECISION);
</span></dt>

<dd><p class="summary-sec">モーションの各キーフレームでの回転移動の状態を示す。<br />

 回転の初期位置は、ボーンのローカル座標の軸がワールド座標の軸と一致している状態であるようだ。<br />

 ここで、ボーンのローカル座標の軸とは、ボーンの斜辺の対角を原点とし、第二長辺をZ軸正の向きとし、
 最短辺と第二長辺の外積をX軸正の向きと定めると、うまくいくようだ。<br />
</p>


</dd>
<dt><span class="decl">class <span class="psymbol">TranslateMotion</span>
;
</span></dt>

<dd><p class="summary-sec">一連のモーションにおける平行移動を表す。<br />

 フレームは [ 0.0, 1.0 ] の浮動小数点数で表す。</p>


<dl class="members-sec"><dt><span class="decl">Vector3!(float)[] <span class="psymbol">translation</span>
;
</span></dt>

<dd><p class="summary-sec">キーフレームにおける移動量</p>


</dd>
<dt><span class="decl">float[] <span class="psymbol">frame</span>
;
</span></dt>

<dd><p class="summary-sec">フレーム数</p>


</dd>
<dt><span class="decl">Vector3f <span class="psymbol">opIndex</span>
(float <span class="param">f</span>
);
</span></dt>

<dd><p class="summary-sec">あるフレームにおける平行移動量を返す。
</p>

<b>Param:</b><br />

<span class="param">f</span>
 = [ 0, 1 ] で、0の時、初期ポーズ、1の時に最終ポーズとなるようにしてある。<br />
<br />
<br />


</dd>
</dl>

</dd>
<dt><span class="decl">class <span class="psymbol">RotateMotion</span>
;
</span></dt>

<dd><p class="summary-sec">一連のモーションにおける回転移動を表す。<br />

 フレームは、[ 0.0, 1.0 ] の浮動小数点数で表す。<br />
</p>


<dl class="members-sec"><dt><span class="decl">Quaternion!(float)[] <span class="psymbol">quaternion</span>
;
</span></dt>

<dd><p class="summary-sec">キーフレームにおける回転量</p>


</dd>
<dt><span class="decl">float[] <span class="psymbol">frame</span>
;
</span></dt>

<dd><p class="summary-sec">[ 0, 1 ]</p>


</dd>
<dt><span class="decl">Quaternionf <span class="psymbol">opIndex</span>
(float <span class="param">f</span>
);
</span></dt>

<dd><p class="summary-sec">あるフレームにおけるクォータニオンを返す。<br />

</p>

<b>Params:</b><br />
<table border="1" frame="void" rules="rows" class="params"><tr><td class="params_id">float <span class="param">f</span>
</td>

<td>[ 0, 1 ] で、0の時、初期ポーズ、1の時に最終ポーズとなるようにしてある。<br />

       後々、モーションの速度とか変えられるようにしたい。<br />
</td></tr>
</table><br />



</dd>
</dl>

</dd>
<dt><span class="decl">struct <span class="psymbol">Transformation</span>
(PRECISION);
</span></dt>

<dd><p class="summary-sec">座標軸を変換する。<br />

 ボーンの姿勢を決定するのに使われる。<br />

 コンストラクタに渡された3つの頂点から新しい座標軸を求める。<br />
</p>


<dl class="members-sec"><dt><span class="decl">Vector3!(PRECISION) <span class="psymbol">translation</span>
;
</span></dt>

<dd><p class="summary-sec">旧座標での、新しい座標の原点の位置</p>


</dd>
<dt><span class="decl">Quaternion!(PRECISION) <span class="psymbol">rotation</span>
;
</span></dt>

<dd><p class="summary-sec">旧座標に対する、新しい座標の傾き</p>


</dd>
<dt><span class="decl">this(Vector3!(PRECISION)[3] <span class="param">vertex</span>
...);
</span></dt>

<dd><b>Params:</b><br />
<table border="1" frame="void" rules="rows" class="params"><tr><td class="params_id">Vector3!(PRECISION)[3] <span class="param">vertex</span>
</td>

<td>3つの頂点からなり、以下の要領で新しい座標を定義する。<br />

            <ul>
              <li><span class="param">vertex</span>
[0] は原点である。</li>
              <li>3つの頂点は新しい座標の Y軸、Z軸を含む平面上にある。</li>
              <li><span class="param">vertex</span>
[0] から見て <span class="param">vertex</span>
[1] が Z軸正の向きである。</li>
              <li><span class="param">vertex</span>
[0] から見て <span class="param">vertex</span>
[2] は 新しい座標で、Z軸から Y の値が正の側にある。</li>
            </ul></td></tr>
</table><br />



</dd>
<dt><span class="decl">void <span class="psymbol">loadIdentity</span>
();
</span></dt>

<dd><p class="summary-sec">単位行列みたいなのを読み込む。</p>


</dd>
<dt><span class="decl">const Transformation <span class="psymbol">opUnary</span>
(string OP : "-")();
</span></dt>

<dd><p class="summary-sec">もとの座標系へと変換する TransformationSet を返す。</p>


</dd>
<dt><span class="decl">const @property Matrix4!(PRECISION) <span class="psymbol">toMatrix</span>
();
</span></dt>

<dd><p class="summary-sec">新しい座標系へと変換する行列を返す。</p>


</dd>
<dt><span class="decl">const @property Matrix4!(PRECISION) <span class="psymbol">toInverseMatrix</span>
();
</span></dt>

<dd><p class="summary-sec">もとの座標系へと変換する行列を返す。</p>


</dd>
<dt><span class="decl">const Transformation <span class="psymbol">opBinary</span>
(string OP : "*")(in Transformation <span class="param">ts</span>
);
<br />
Transformation <span class="psymbol">opOpAssign</span>
(string OP : "*")(in Transformation <span class="param">ts</span>
);
</span></dt>

<dd><p class="summary-sec">変換を追加する。行列と同じで、左から追加する。</p>


</dd>
<dt><span class="decl">const Transformation <span class="psymbol">opBinary</span>
(string OP : "*")(in Quaternion!(PRECISION) <span class="param">q</span>
);
<br />
Transformation <span class="psymbol">opOpAssign</span>
(string OP : "*")(in Quaternion!(PRECISION) <span class="param">q</span>
);
</span></dt>

<dd><p class="summary-sec">回転だけ追加する。</p>


</dd>
<dt><span class="decl">const Transformation <span class="psymbol">opBinary</span>
(string OP : "+")(in Vertex3!(PRECISION) <span class="param">v</span>
);
<br />
Transformation <span class="psymbol">opOpAssign</span>
(string OP : "+")(in Vector3!(PRECISION) <span class="param">v</span>
);
</span></dt>

<dd><p class="summary-sec">平行移動を追加する場合は演算子が "+" なので注意。</p>


</dd>
<dt><span class="decl">const Vector3!(PRECISION) <span class="psymbol">opBinary</span>
(string OP : "*")(in Vector3!(PRECISION) <span class="param">v</span>
);
</span></dt>

<dd><p class="summary-sec">変換を v に対して実行する。</p>


</dd>
</dl>

</dd>
<dt><span class="decl">struct <span class="psymbol">OBBox</span>
;
</span></dt>

<dd><p class="summary-sec">当り判定用</p>


<dl class="members-sec"><dt><span class="decl">Tranf <span class="psymbol">localize</span>
;
</span></dt>

<dd><p class="summary-sec">自分の座標系に変換する。</p>


</dd>
<dt><span class="decl">const @property ref const(Vector3f) <span class="psymbol">width2</span>
();
</span></dt>

<dd><p class="summary-sec">重心が原点にくるようになっているはずなので、頂点座標は一つでよい。</p>


</dd>
<dt><span class="decl">const float <span class="psymbol">shadowLength2</span>
(ref const(Vector3f) <span class="param">v</span>
);
</span></dt>

<dd><p class="summary-sec">入力されたベクトルに影を投影し、その長さ(の半分)を求める。</p>


</dd>
<dt><span class="decl">const bool <span class="psymbol">isCollide</span>
(ref const(OBBox) <span class="param">ob</span>
);
</span></dt>

<dd><p class="summary-sec">当り判定をする。</p>


</dd>
</dl>

</dd>
<dt><span class="decl">string <span class="psymbol">searchFile</span>
(string <span class="param">filename</span>
, string[] <span class="param">bases</span>
...);
</span></dt>

<dd><p class="summary-sec">ファイルを探す。
</p>

<b>Params:</b><br />
<table border="1" frame="void" rules="rows" class="params"><tr><td class="params_id">string <span class="param">filename</span>
</td>

<td>ファイル名</td></tr>
<tr><td class="params_id">string[] <span class="param">bases</span>
</td>

<td>検索するパス</td></tr>
</table><br />



</dd>
<dt><span class="decl">struct <span class="psymbol">HitState</span>
(PRECISION);
</span></dt>

<dd><p class="summary-sec">直線とポリゴンの交差状態を格納する。</p>


<dl class="members-sec"><dt><span class="decl">PRECISION <span class="psymbol">distance</span>
;
</span></dt>

<dd><p class="summary-sec">点とポリゴンとの交点の距離</p>


</dd>
<dt><span class="decl">bool <span class="psymbol">clockwise</span>
;
</span></dt>

<dd><p class="summary-sec">点から見てポリゴンが時計回りの時 -&gt; <span class="dkeyword">true</span>

 OpenGL系では、点から見てポリゴンが時計回りの時は、その点はポリゴンの裏側にある。</p>


</dd>
</dl>

</dd>
<dt><span class="decl">void <span class="psymbol">crossState</span>
(PRECISION)(ref HitState!(PRECISION) <span class="param">hs</span>
, ref const(Arrow!(PRECISION)) <span class="param">arr</span>
, in uint[] <span class="param">face</span>
, in Vector3!(PRECISION)[] <span class="param">vertex</span>
);
</span></dt>

<dd><p class="summary-sec">無限直線 arr が、TRIANGLE を形成する face、 vertex と交差するか、どう交差するか？(表から？裏から？)を判定している。<br />

 点 arr.p が TRIANGLE表面上にあり、直線 arr.v がポリゴン平面と平行の場合、
 直線は「TRIANGLE表から」「交差」と判定される。<br />

 点 arr.p が TRIANGLE表面上になく、直線 arr.v が TRIANGLE表面と平行にTRIANGLE表面上を通る場合、直線は「交差なし」と判定される。<br />

 それ以外の場合、TRIANGLE表面、境界および頂点上は「交差」と判定される。<br />

</p>

<b>Params:</b><br />
<table border="1" frame="void" rules="rows" class="params"><tr><td class="params_id">hs</td>

<td>hs に予め収められている距離より近かった場合のみ、これを更新する。<br />

            表裏が同じ距離にあった場合、表を優先する。<br />
</td></tr>
<tr><td class="params_id">arr</td>

<td>調べたい直線。arr.v は正規化されているものとする。<br />

            正規化されていない場合、表裏判定は同じだが hs.dist の値はデタラメになる。<br />
</td></tr>
<tr><td class="params_id">face</td>

<td>TRIANGLEを定義するインデックス配列<br />
</td></tr>
<tr><td class="params_id">vertex</td>

<td>TRIANGLEを成形する頂点配列<br />
</td></tr>
</table><br />


<b>Throws:</b><br />

face.length &lt; 3 もしくは face が示す先より vertex が短かかった場合、 Range violation が投げられる。<br />
<br />


</dd>
<dt><span class="decl">PRECISION <span class="psymbol">depthIn</span>
(PRECISION)(in Arrow!(PRECISION) <span class="param">arr</span>
, in Vector3!(PRECISION)[] <span class="param">vertex</span>
, uint[] <span class="param">index</span>
);
</span></dt>

<dd><p class="summary-sec">点 p が、メッシュの内側にあるかどうか？どの位の深さにあるか？を測定する。<br />

 メッシュは閉じており、(OpenGL的に)表裏が正しいと仮定する。<br />

 ( OpenGL では反時計回り順のポリゴンが表 )<br />

 任意方向での最寄りのポリゴンの裏が見えているかどうかを判定している。<br />

 裏が見えていれば、点はメッシュの内にある。<br />

 境界上は外側となる。<br />

</p>

<b>Params:</b><br />
<table border="1" frame="void" rules="rows" class="params"><tr><td class="params_id">arr</td>

<td>arr.p が対象の点。arr.v が、どの方向での深さを調べるかを示す。</td></tr>
<tr><td class="params_id">vertex</td>

<td>メッシュを構成する。</td></tr>
<tr><td class="params_id">index</td>

<td>メッシュを定義する。</td></tr>
</table><br />


<b>Returns:</b><br />

深さが返る。点がメッシュに含まれなかった場合は、負の数が返る。<br />
<br />


</dd>
</dl>


  </body>
</html>

