<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C/DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
  <head>
    <meta http-equiv = "Content-Type" content = "text/html; charset=utf-8" />
    <meta http-equiv = "Content-Style-Type" content = "text/css" />
    <meta http-equiv = "Content-Script-Type" content = "text/javascript" />
  </head>
  <body>
    <h1>sworks.mqo.mqo</h1>
    <!-- Generated by Ddoc from src\sworks\mqo\mqo.d -->
<p class='summary-sec'>Metasequoia モデルのファイルフォーマット .<span class='psymbol'>mqo</span> を読み込む。
</p>
<span class='summary-header-sec version-sec'>0.0001(dmd2.062)
</span><br />

<span class='summary-header-sec date-sec'>2013-Mar-27 03:45:29
</span><br />

<span class='summary-header-sec authors-sec'>KUMA
</span><br />

<span class='summary-header-sec license-sec'>CC0</span><br />


<dl class='module-members-sec'><dt><span class='decl'><a name="MQObject"></a>class <span class='psymbol'>MQObject</span>;
</span></dt>
<dd><p class='summary-sec'>.mqo を表現する最外のオブジェクト
 メンバがそれぞれのチャンクを表現している。
</p>
<p class='bug-sec'><span class='psymbol'>MQObject</span> のメンバには全て、引数無しのコンストラクタが必要</p>

<dl class='members-sec'><dt><span class='decl'><a name="MQObject.HEADER"></a>string <span class='psymbol'>HEADER</span>;
</span></dt>
<dd><p class='summary-sec'>.mqo ファイルのヘッダにヒットする正規表現<br />

 sworks.compo.util.dregex を使っている。(ver 0.0014以降)<br />

 <del>Captures[1] にバージョン文字列が入るようにしてある。</del>( ver0.0011以降 )<br />

 <del>ファイル先頭からヴァージョン文字列直前までの文字列を入れておく。</del><br />

 BOM はついていないものと仮定する。<br />

 <del>コンパイル時に std.regex が使えないからだきょった orz...</del><br />
</p>

</dd>
<dt><span class='decl'><a name="MQObject.version_string"></a>string <span class='psymbol'>version_string</span>;
</span></dt>
<dd><p class='summary-sec'>メタセコイアファイルフォーマットのバージョン。(現在 1.0 )</p>

</dd>
<dt><span class='decl'><a name="MQObject.scene"></a>SceneChunk <span class='psymbol'>scene</span>;
</span></dt>
<dd><p class='summary-sec'>Scene チャンク</p>

</dd>
<dt><span class='decl'><a name="MQObject.material"></a>Material[] <span class='psymbol'>material</span>;
</span></dt>
<dd><p class='summary-sec'>Material チャンク</p>

</dd>
<dt><span class='decl'><a name="MQObject.object"></a>ObjectChunk[jstring] <span class='psymbol'>object</span>;
</span></dt>
<dd><p class='summary-sec'>Object チャンク</p>

</dd>
<dt><span class='decl'><a name="MQObject.noise_chunk"></a>void* <span class='psymbol'>noise_chunk</span>;
</span></dt>
<dd><p class='summary-sec'>not supported.</p>

</dd>
<dt><span class='decl'><a name="MQObject.include_xml"></a>string <span class='psymbol'>include_xml</span>;
</span></dt>
<dd><p class='summary-sec'>not supported.</p>

</dd>
<dt><span class='decl'><a name="MQObject.back_image"></a>string <span class='psymbol'>back_image</span>;
</span></dt>
<dd><p class='summary-sec'>not supported.</p>

</dd>
<dt><span class='decl'><a name="MQObject.blob"></a>string <span class='psymbol'>blob</span>;
</span></dt>
<dd><p class='summary-sec'>not supported.</p>

</dd>
<dt><span class='decl'><a name="MQObject.optimizeForGL"></a>void <span class='psymbol'>optimizeForGL</span>();
</span></dt>
<dd><p class='summary-sec'>OpenGL用に最適化<br />

 現在、
 <ul>
   <li> BVertexチャンク を Vertexチャンクに読み込み</li>
   <li> Face の表裏を反転(メタセコイアとOpenGLでは表裏が逆)</li>
   <li> mirror を展開。</li>
 </ul>
 をしている。
</p>
<p class='bug-sec'>表面を継げての mirror 展開にはまだ対応していません。</p>

</dd>
</dl>
</dd>
<dt><span class='decl'><a name="SceneChunk"></a>class <span class='psymbol'>SceneChunk</span>;
</span></dt>
<dd><p class='summary-sec'>Scene チャンクの表現</p>

<dl class='members-sec'><dt><span class='decl'><a name="SceneChunk.pos"></a>Vector3f <span class='psymbol'>pos</span>;
<br />
<a name="SceneChunk.lookat"></a>Vector3f <span class='psymbol'>lookat</span>;
<br />
<a name="SceneChunk.head"></a>float <span class='psymbol'>head</span>;
<br />
<a name="SceneChunk.pich"></a>float <span class='psymbol'>pich</span>;
<br />
<a name="SceneChunk.bank"></a>float <span class='psymbol'>bank</span>;
<br />
<a name="SceneChunk.ortho"></a>int <span class='psymbol'>ortho</span>;
<br />
<a name="SceneChunk.zoom2"></a>float <span class='psymbol'>zoom2</span>;
<br />
<a name="SceneChunk.amb"></a>Color3f <span class='psymbol'>amb</span>;
<br />
<a name="SceneChunk.dirlights"></a>DirlightsChunk[] <span class='psymbol'>dirlights</span>;
</span></dt>
<dd><p class='summary-sec'>本家ページでは詳細が省略されている</p>

</dd>
</dl>
</dd>
<dt><span class='decl'><a name="Material"></a>class <span class='psymbol'>Material</span>: sworks.mqo.parser.IOwnParser;
</span></dt>
<dd><p class='summary-sec'><span class='psymbol'>Material</span> チャンク内のそれぞれの <span class='psymbol'>Material</span> の表現</p>

<dl class='members-sec'><dt><span class='decl'><a name="Material.name"></a>jstring <span class='psymbol'>name</span>;
</span></dt>
<dd><p class='summary-sec'>材質名</p>

</dd>
<dt><span class='decl'><a name="Material.shader"></a>int <span class='psymbol'>shader</span>;
</span></dt>
<dd><p class='summary-sec'>シェーダ<br />

 0 Classic<br />

 1 Constant<br />

 2 Lambert<br />

 3 Phong<br />

 4 Blinn<br />
</p>

</dd>
<dt><span class='decl'><a name="Material.vcol"></a>int <span class='psymbol'>vcol</span>;
</span></dt>
<dd><p class='summary-sec'>頂点カラー<br />

 0 なし<br />

 1 あり<br />
</p>

</dd>
<dt><span class='decl'><a name="Material.col"></a>Color4f <span class='psymbol'>col</span>;
</span></dt>
<dd><p class='summary-sec'>色 ( R G B A ) 各色 [ 0, 1 ]</p>

</dd>
<dt><span class='decl'><a name="Material.dif"></a>float <span class='psymbol'>dif</span>;
</span></dt>
<dd><p class='summary-sec'>拡散光 [ 0, 1 ]</p>

</dd>
<dt><span class='decl'><a name="Material.amb"></a>float <span class='psymbol'>amb</span>;
</span></dt>
<dd><p class='summary-sec'>周囲光 [ 0, 1 ]</p>

</dd>
<dt><span class='decl'><a name="Material.emi"></a>float <span class='psymbol'>emi</span>;
</span></dt>
<dd><p class='summary-sec'>自己照明 [ 0, 1 ]</p>

</dd>
<dt><span class='decl'><a name="Material.spc"></a>float <span class='psymbol'>spc</span>;
</span></dt>
<dd><p class='summary-sec'>反射光 [ 0, 1 ]</p>

</dd>
<dt><span class='decl'><a name="Material.power"></a>float <span class='psymbol'>power</span>;
</span></dt>
<dd><p class='summary-sec'>反射光の強さ。 [ 0, 100 ]</p>

</dd>
<dt><span class='decl'><a name="Material.tex"></a>jstring <span class='psymbol'>tex</span>;
</span></dt>
<dd><p class='summary-sec'>模様マッピング名 ( 相対パス )</p>

</dd>
<dt><span class='decl'><a name="Material.aplane"></a>jstring <span class='psymbol'>aplane</span>;
</span></dt>
<dd><p class='summary-sec'>透明マッピング名 ( 相対パス )</p>

</dd>
<dt><span class='decl'><a name="Material.bump"></a>jstring <span class='psymbol'>bump</span>;
</span></dt>
<dd><p class='summary-sec'>凹凸マッピング名 ( 相対パス )</p>

</dd>
<dt><span class='decl'><a name="Material.proj_type"></a>int <span class='psymbol'>proj_type</span>;
</span></dt>
<dd><p class='summary-sec'>マッピング方式<br />

 0 UV
 1 平面
 2 円筒
 3 球</p>

</dd>
<dt><span class='decl'><a name="Material.proj_pos"></a>Vector3f <span class='psymbol'>proj_pos</span>;
</span></dt>
<dd><p class='summary-sec'>投影位置 ( x y z )</p>

</dd>
<dt><span class='decl'><a name="Material.proj_scale"></a>Vector3f <span class='psymbol'>proj_scale</span>;
</span></dt>
<dd><p class='summary-sec'>投影拡大率 ( x y z )</p>

</dd>
<dt><span class='decl'><a name="Material.proj_angle"></a>Vector3f <span class='psymbol'>proj_angle</span>;
</span></dt>
<dd><p class='summary-sec'>投影角度 ( H P B ) [ -180, 180 ]</p>

</dd>
<dt><span class='decl'><a name="Material.getName"></a>jstring <span class='psymbol'>getName</span>(float <span class='param'>x</span> = 0);
</span></dt>
<dd><p class='summary-sec'>Mikoto 用。材質名を展開して返す。<br />

 name が、"腕[]" みたいになっていた場合、<span class='param'>x</span> が正の時は "腕[L]"に、<span class='param'>x</span> が負の場合は "腕[R]" に展開する。<br />

 name が、"体" みたいな時はそのまま返す。<br />
</p>

</dd>
</dl>
</dd>
<dt><span class='decl'><a name="ObjectChunk"></a>class <span class='psymbol'>ObjectChunk</span>: sworks.mqo.parser.INamable;
</span></dt>
<dd><p class='summary-sec'>オブジェクトチャンク</p>

<dl class='members-sec'><dt><span class='decl'><a name="ObjectChunk.depth"></a>int <span class='psymbol'>depth</span>;
</span></dt>
<dd><p class='summary-sec'>階層の深さ。ルート直下を 0 として深くなるごとに +1。</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.folding"></a>int <span class='psymbol'>folding</span>;
</span></dt>
<dd><p class='summary-sec'>オブジェクトパネル上の階層の折りたたみ。<br />

 0 通常表示<br />

 1 子オブジェクトを折りたたんで非表示<br />
</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.scale"></a>Vector3f <span class='psymbol'>scale</span>;
</span></dt>
<dd><p class='summary-sec'>ローカル座標の拡大率 ( x y z )</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.rotation"></a>Vector3f <span class='psymbol'>rotation</span>;
</span></dt>
<dd><p class='summary-sec'>ローカル座標の回転角 ( H P B )</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.translation"></a>Vector3f <span class='psymbol'>translation</span>;
</span></dt>
<dd><p class='summary-sec'>ローカル座標の平行移動量 ( x y z )</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.patch"></a>int <span class='psymbol'>patch</span>;
</span></dt>
<dd><p class='summary-sec'>曲面の形式<br />

 0 平面(曲面指定をしない)<br />

 1 曲面タイプ1 ( スプライン Type1 )<br />

 2 曲面タイプ2 ( スプライン Type2 )<br />

 3 Catmull-Clark ( Metasequoia Ver2.2以降 )
</p>
<p class='bug-sec'>0 以外対応してません。</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.segment"></a>int <span class='psymbol'>segment</span>;
</span></dt>
<dd><p class='summary-sec'>曲面の分割数<br />

 patch = 1 .. 3 の時[ 1, 16 ]<br />

 patch = 3 の時 [ 1, 4 ] ( Catmull-Clarkの場合、再帰分割数を示すため)<br />
</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.visible"></a>int <span class='psymbol'>visible</span>;
</span></dt>
<dd><p class='summary-sec'>表示、非表示<br />

 0 非表示<br />

 15 表示<br />
</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.locking"></a>int <span class='psymbol'>locking</span>;
</span></dt>
<dd><p class='summary-sec'>オブジェクトの固定<br />

 0 編集可能<br />

 1 編集禁止<br />
</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.shading"></a>int <span class='psymbol'>shading</span>;
</span></dt>
<dd><p class='summary-sec'>シェーディング<br />

 0 フラットシェーディング<br />

 1 グローシェーディング<br />
</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.facet"></a>float <span class='psymbol'>facet</span>;
</span></dt>
<dd><p class='summary-sec'>スムージング角度 [ 0, 180 ]</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.color"></a>Color3f <span class='psymbol'>color</span>;
</span></dt>
<dd><p class='summary-sec'>色 ( R G B ) それぞれ [ 0, 1 ]</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.color_type"></a>int <span class='psymbol'>color_type</span>;
</span></dt>
<dd><p class='summary-sec'>辺の色タイプ<br />

 0 環境設定での色を使用<br />

 1 オブジェクト固有の色を使用<br />
</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.mirror"></a>int <span class='psymbol'>mirror</span>;
</span></dt>
<dd><p class='summary-sec'>鏡面のタイプ<br />

 0 なし<br />

 1 左右を分離<br />

 2 左右を接続(対応してません。)<br />
</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.mirror_axis"></a>int <span class='psymbol'>mirror_axis</span>;
</span></dt>
<dd><p class='summary-sec'>鏡面の適用軸<br />

 1 X軸<br />

 2 Y軸<br />

 3 Z軸<br />
</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.mirror_dis"></a>float <span class='psymbol'>mirror_dis</span>;
</span></dt>
<dd><p class='summary-sec'>接続距離 [ 0, float.max ]</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.lathe"></a>int <span class='psymbol'>lathe</span>;
</span></dt>
<dd><p class='summary-sec'>回転体のタイプ<br />

 0 なし<br />

 3 両面(対応してません。)<br />
</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.lathe_axis"></a>int <span class='psymbol'>lathe_axis</span>;
</span></dt>
<dd><p class='summary-sec'>回転体の軸<br />

 0 X軸<br />

 1 Y軸<br />

 2 Z軸<br />
</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.lathe_seg"></a>int <span class='psymbol'>lathe_seg</span>;
</span></dt>
<dd><p class='summary-sec'>回転体の分割数 [ 3, int.max ]</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.vertex"></a>Vector3f[] <span class='psymbol'>vertex</span>;
</span></dt>
<dd><p class='summary-sec'>Vertex チャンク</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.vertexattr"></a>VertexAttrChunk <span class='psymbol'>vertexattr</span>;
</span></dt>
<dd><p class='summary-sec'>Metasequoia Ver2.2以降</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.face"></a>Face[] <span class='psymbol'>face</span>;
</span></dt>
<dd><p class='summary-sec'>Face チャンク</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.checkBVertex"></a>void <span class='psymbol'>checkBVertex</span>();
</span></dt>
<dd><p class='summary-sec'>BVertex をチェックし、もし存在するなら vertex チャンクに Shallow Copy する。</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.reverseFaces"></a>void <span class='psymbol'>reverseFaces</span>();
</span></dt>
<dd><p class='summary-sec'>表裏を反転させる。<br />

</p>
<p class='bug-sec'>実際の表裏を考慮しない。なんでもかんでも逆にする。</p>

</dd>
<dt><span class='decl'><a name="ObjectChunk.expandMirror"></a>void <span class='psymbol'>expandMirror</span>();
</span></dt>
<dd><p class='summary-sec'>ミラー処理を展開する。
</p>
<p class='bug-sec'>2 == mirror の「左右を接続」にはまだ対応していない。</p>

</dd>
</dl>
</dd>
<dt><span class='decl'><a name="BVertexChunk"></a>class <span class='psymbol'>BVertexChunk</span>;
</span></dt>
<dd><p class='summary-sec'>BVertex チャンク</p>

</dd>
<dt><span class='decl'><a name="VertexAttrChunk"></a>class <span class='psymbol'>VertexAttrChunk</span>;
</span></dt>
<dd><p class='summary-sec'>VertexAttr チャンク</p>

</dd>
<dt><span class='decl'><a name="Face"></a>class <span class='psymbol'>Face</span>: sworks.mqo.parser.ILength, sworks.mqo.parser.IOwnParser;
</span></dt>
<dd><p class='summary-sec'><span class='psymbol'>Face</span> チャンク内のそれぞれの <span class='psymbol'>Face</span></p>

<dl class='members-sec'><dt><span class='decl'><a name="Face.parser"></a>bool <span class='psymbol'>parser</span>(ref Token <span class='param'>token</span>);
</span></dt>
<dd><p class='summary-sec'>Face チャンク内は書式が例外的なので専用のパーサを持つ。</p>

</dd>
<dt><span class='decl'><a name="Face.reverse"></a>void <span class='psymbol'>reverse</span>();
</span></dt>
<dd><p class='summary-sec'>表裏を逆にする。Metasequoia は OpenGL とは表裏が逆。</p>

</dd>
<dt><span class='decl'><a name="Face.dup"></a>const Face <span class='psymbol'>dup</span>();
</span></dt>
<dd><p class='summary-sec'>複製する。</p>

</dd>
<dt><span class='decl'><a name="Face.subTriangleFan"></a>const Face <span class='psymbol'>subTriangleFan</span>(uint <span class='param'>i</span>);
</span></dt>
<dd><p class='summary-sec'>TRIANGLE_FAN(と仮定して) <span class='param'>i</span> 個目の TRIANGLE を抜き出す。</p>

</dd>
</dl>
</dd>
<dt><span class='decl'><a name="WeitChunk"></a>struct <span class='psymbol'>WeitChunk</span>;
</span></dt>
<dd><p class='summary-sec'>Weit チャンク // not supported</p>

</dd>
<dt><span class='decl'><a name="ColorChunk"></a>struct <span class='psymbol'>ColorChunk</span>;
</span></dt>
<dd><p class='summary-sec'>Color チャンク // not supported</p>

</dd>
</dl>

  </body>
</html>

